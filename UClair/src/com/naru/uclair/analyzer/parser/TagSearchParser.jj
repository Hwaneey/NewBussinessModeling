
options {
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
}

PARSER_BEGIN(TagSearchParser)
package com.naru.uclair.analyzer.parser.tagsearch;

import javax.script.ScriptContext;
import java.util.*;

/**
 * 태그 찾기 파서
 * 문법은 다음과 같다.
 * 
 * 변수 = "값" <엔터>
 * 
 * 메소드 단위테스트는 필요하지 않음. 
 * ResourceParser.jj를 컴파일하여 자동으로 생성된 코드임.
 * @author SungKwon Choi
 *  2008 2008. 12. 26. 오후 4:47:19
 */
public class TagSearchParser {
	public Hashtable symtab ;
	public Hashtable tagMap ;

	public TagSearchParser()	{		this.symtab = new Hashtable();
		this.tagMap = new Hashtable();
	}

	public Hashtable tagSearch() throws ParseException
	{
		input(symtab);

		return symtab;
	}
}

PARSER_END(TagSearchParser)


void init(Hashtable symtab)
{
    Token t1, t2;
}
{
    assign()
    |
    tag()
      
}

void assign()
{}
{
  <IDENTIFIER> "=" exp()}

void tag(){
  Token t1 = null, t2 = null, t3 = null;}
{
 	"Tag." <IDENTIFIER> "("    (		[t1 = <IDENTIFIER>] t2 = <STRING_LITERAL> [t3 = <IDENTIFIER>]
		{
		    String valueText ="";			if(t1.image != null)			{				valueText += "?";
			}
			if(t2.image != null)			{				valueText += t2.image;
			}
			if(t3.image != null)
			{
				valueText += "?";
			}
			
		}
	}
	")" ";"}

void input() :
{
  Token t1, t2;
}
{

  (
    LOOKAHEAD(3)
    t1=<IDENTIFIER> <ASSIGN> (t2=<IDENTIFIER> | t2=<DOUBLE_LITERAL> | t2=<INTEGER_LITERAL>)
	{
		String stringval = t2.image;
		symtab.put(t1.image , stringval); 
	}
	|
	LOOKAHEAD(3)
    t1=<IDENTIFIER> <ASSIGN> t2=<STRING_LITERAL>
	{
		String stringval = t2.image.substring(1,t2.image.length()-1);
		stringval = stringval.replaceAll("\\\\r","\r");
		stringval = stringval.replaceAll("\\\\t","\t");
		symtab.put(t1.image , stringval); 
	}	
	|
	t1=<IDENTIFIER> <ASSIGN>
	{
		symtab.put(t1.image , "");
	}
	
  )*
  <EOF>
}

// Lexical specifications follow (copied from the Java 1.1 grammar)

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"

}

SKIP : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: ("//" | "#") (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* RESERVED WORDS */
{
  < ASSIGN: "=" >
}

TOKEN : /* LITERALS */
{
  < DOUBLE_LITERAL:  (["0"-"9"])+ "." (["0"-"9"])* >
  |
  < INTEGER_LITERAL: (<DIGIT>)+ >
  |
  < STRING_LITERAL :  
  "\""
  ( (~["\"","\\"])
    | ("\\"  
      ( [ "n", "t", "b", "r", "f", "\\", "'", "\"", "\n", "\r" ]
        | ["0"-"7"] ( ["0"-"7"] )?
        | ["0"-"3"] ["0"-"7"] ["0"-"7"]
       )
      )
   )*
  "\""  > 
  |
  <PROTOCOL_LITERAL : ["a"-"z", "A"-"Z", ".", " ", "-", "(", ")"]>
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff",
       "a"-"z", "A"-"Z", "."
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}
